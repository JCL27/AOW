Informe del trabajo práctico de POO

Detalles
Nombre del proyecto: Age of War.
Link al juego original: Age of War 
Integrantes: Mercado Matías - 55019, Lepore Juan Cruz - 55124
Back-end
Al iniciar el juego se instancia Game, la clase encargada de actualizar el estado del juego (ya que tiene el método Render) y realizar las tareas relacionadas con el manejo de archivos como guardar y cargar partida. La lógica del juego está construida alrededor de la clase WorldManager, la cual tiene dos Players, uno que es la persona que juega, y el otro la AI. Cada Player tiene un vector de Units, y otro de Projectiles, además de una Base y una Tower que puede estar instanciada o no. Las Units avanzan hacia la Base enemiga atacando a las Units contrarias que encuentren en el camino, mediante la generación de Projectiles si es que son de rango. Unit, Projectile y Base tienen un Element por instancia, este se encarga de llevar cuenta de la posición y del tamaño que ocupa cada uno, sirviendo para calcular las colisiones. Cada vez que se desea agregar una Unit, Tower o Projectile, se llama a Factory, la cual devuelve una instancia de la clase correspondiente, asignándole su observer en caso de estar trabajando con algún front-end. Las unidades pueden recibir mejoras a sus atributos mediante algún Upgrade, el cual modifica estáticamente la clase de la unidad, haciendo que la mejora no sea retroactiva, es decir, que sólo afecte a las unidades instanciadas de ahí en adelante. También se utiliza la clase Upgrade para investigar el uso de nuevos tipos de unidades.
Front-end
El front-end es administrado por UIManager, una clase Singleton cuya función es decidir qué debe mostrar en cada momento y dibujar en pantalla dichos elementos. La ubicación de los elementos a dibujar se obtiene a través de observers, que son pasados como parámetros a los elementos del back, pero que pueden no estar.
Consideraciones
En una primera instancia se diseñó un sistema de Upgrades en donde seguían un árbol de mejoras, el cual se actualizaba con cada upgrade utilizada. Pero por falta de tiempo la implementación quedó a la mitad, por lo que se decidió dejar sólo seis tipos de Upgrades, y el método quedó sobredimensionado.
Por otro lado, se consideró que sería mejor tener un solo observer para cada tipo de elemento (Unit, Base, Player o Projectile), y se hizo que el observer no tenga referencias a ninguna otra clase para ayudar a que quede desacoplado.
